name: Helm Deployment (Local)
on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: self-hosted
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Ensure Local Docker Registry Is Running (Windows)
        shell: pwsh
        run: |
          $registryExists = docker ps --format "{{.Names}}" | Select-String "registry"
          if (-not $registryExists) {
            docker run -d -p 5000:5000 --restart=always --name registry registry:2
          }

      - name: Build and Push Local Docker Image
        run: |
          cd WEB
          docker build --no-cache -t coweb-app:latest .
          docker tag coweb-app:latest localhost:5000/coweb-app:latest
          docker push localhost:5000/coweb-app:latest
          cd ..

      - name: Ensure Namespace Exists
        run: |
          kubectl get ns coweb-ns || kubectl create ns coweb-ns

      - name: Set Kubernetes Context to Docker Desktop
        run: |
          kubectl config use-context docker-desktop

      - name: Lint Helm Chart
        run: |
          helm lint ./coweb

      - name: Deploy with Helm (Stable Setup)
        run: |
          # helm upgrade --install coweb ./coweb --namespace coweb-ns --set image.repository=localhost:5000/coweb-app --set image.tag=latest --set image.pullPolicy=Always --wait
          helm upgrade --install coweb ./coweb --namespace coweb-ns `
            --set image.repository="localhost:5000/coweb-app" `
            --set image.tag="latest" `
            --set image.pullPolicy="Always" `
            --wait

      - name: Restart Deployment to Apply Latest Image
        run: |
          kubectl rollout restart deployment/coweb -n coweb-ns

      - name: Verify Deployment
        run: |
          kubectl get all -n coweb-ns
          kubectl get svc -n coweb-ns

      - name: Rollback on Failure
        if: ${{ failure() }}
        run: |
          kubectl rollout undo deployment/coweb -n coweb-ns

      # Removed: ArgoCD CLI installation, assuming it's pre-installed

      - name: Install ArgoCD in the local k8s cluster
        run: |
          kubectl apply -n argocd -f "https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml"

      - name: Wait for ArgoCD to be Available
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

      - name: Port Forward ArgoCD Server (Windows-safe)
        shell: pwsh
        run: |
          Start-Process -NoNewWindow -FilePath "kubectl" -ArgumentList "port-forward svc/argocd-server -n argocd 8080:443"

      - name: Validate ArgoCD CLI Execution
        shell: pwsh
        run: |
          if (!(Test-Path "$env:USERPROFILE\argocd.exe")) {
            Write-Error "ArgoCD CLI not found!"
            exit 1
          }

      # - name: Login to ArgoCD
      #   shell: pwsh
      #   run: |
      #     & "$env:USERPROFILE\argocd.exe" login localhost:8080 --username admin --password $env:ARGOCD_PASSWORD --grpc-web --insecure
      #   env:
      #     ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}

      - name: Deploy with ArgoCD (Bash)
        shell: bash
        run: |
          set -e
          argocd app sync coweb-app --grpc-web
          argocd app wait coweb-app --health --timeout 300

      - name: Wait for Service and Port Forward
        shell: bash
        run: |
          until kubectl get svc coweb-service -n coweb-ns; do
            echo "Waiting for service..."
            sleep 5
          done
          kubectl port-forward svc/coweb-service 32000:80 -n coweb-ns &

      - name: Verify Service
        shell: bash
        run: |
          sleep 10
          if ! curl -s http://localhost:32000; then
            echo "Service is not reachable!"
            exit 1
          else
            echo "Service is reachable!"
          fi